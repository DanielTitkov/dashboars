// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/migrate"

	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/dimension"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/item"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/metric"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/task"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/taskcategory"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/taskinstance"
	"github.com/DanielTitkov/dashboars/internal/repository/entgo/ent/tasktag"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Dimension is the client for interacting with the Dimension builders.
	Dimension *DimensionClient
	// Item is the client for interacting with the Item builders.
	Item *ItemClient
	// Metric is the client for interacting with the Metric builders.
	Metric *MetricClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TaskCategory is the client for interacting with the TaskCategory builders.
	TaskCategory *TaskCategoryClient
	// TaskInstance is the client for interacting with the TaskInstance builders.
	TaskInstance *TaskInstanceClient
	// TaskTag is the client for interacting with the TaskTag builders.
	TaskTag *TaskTagClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Dimension = NewDimensionClient(c.config)
	c.Item = NewItemClient(c.config)
	c.Metric = NewMetricClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TaskCategory = NewTaskCategoryClient(c.config)
	c.TaskInstance = NewTaskInstanceClient(c.config)
	c.TaskTag = NewTaskTagClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Dimension:    NewDimensionClient(cfg),
		Item:         NewItemClient(cfg),
		Metric:       NewMetricClient(cfg),
		Task:         NewTaskClient(cfg),
		TaskCategory: NewTaskCategoryClient(cfg),
		TaskInstance: NewTaskInstanceClient(cfg),
		TaskTag:      NewTaskTagClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Dimension:    NewDimensionClient(cfg),
		Item:         NewItemClient(cfg),
		Metric:       NewMetricClient(cfg),
		Task:         NewTaskClient(cfg),
		TaskCategory: NewTaskCategoryClient(cfg),
		TaskInstance: NewTaskInstanceClient(cfg),
		TaskTag:      NewTaskTagClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Dimension.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Dimension.Use(hooks...)
	c.Item.Use(hooks...)
	c.Metric.Use(hooks...)
	c.Task.Use(hooks...)
	c.TaskCategory.Use(hooks...)
	c.TaskInstance.Use(hooks...)
	c.TaskTag.Use(hooks...)
}

// DimensionClient is a client for the Dimension schema.
type DimensionClient struct {
	config
}

// NewDimensionClient returns a client for the Dimension from the given config.
func NewDimensionClient(c config) *DimensionClient {
	return &DimensionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dimension.Hooks(f(g(h())))`.
func (c *DimensionClient) Use(hooks ...Hook) {
	c.hooks.Dimension = append(c.hooks.Dimension, hooks...)
}

// Create returns a create builder for Dimension.
func (c *DimensionClient) Create() *DimensionCreate {
	mutation := newDimensionMutation(c.config, OpCreate)
	return &DimensionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dimension entities.
func (c *DimensionClient) CreateBulk(builders ...*DimensionCreate) *DimensionCreateBulk {
	return &DimensionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dimension.
func (c *DimensionClient) Update() *DimensionUpdate {
	mutation := newDimensionMutation(c.config, OpUpdate)
	return &DimensionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DimensionClient) UpdateOne(d *Dimension) *DimensionUpdateOne {
	mutation := newDimensionMutation(c.config, OpUpdateOne, withDimension(d))
	return &DimensionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DimensionClient) UpdateOneID(id int) *DimensionUpdateOne {
	mutation := newDimensionMutation(c.config, OpUpdateOne, withDimensionID(id))
	return &DimensionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dimension.
func (c *DimensionClient) Delete() *DimensionDelete {
	mutation := newDimensionMutation(c.config, OpDelete)
	return &DimensionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DimensionClient) DeleteOne(d *Dimension) *DimensionDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DimensionClient) DeleteOneID(id int) *DimensionDeleteOne {
	builder := c.Delete().Where(dimension.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DimensionDeleteOne{builder}
}

// Query returns a query builder for Dimension.
func (c *DimensionClient) Query() *DimensionQuery {
	return &DimensionQuery{
		config: c.config,
	}
}

// Get returns a Dimension entity by its id.
func (c *DimensionClient) Get(ctx context.Context, id int) (*Dimension, error) {
	return c.Query().Where(dimension.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DimensionClient) GetX(ctx context.Context, id int) *Dimension {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItem queries the item edge of a Dimension.
func (c *DimensionClient) QueryItem(d *Dimension) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dimension.Table, dimension.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dimension.ItemTable, dimension.ItemPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DimensionClient) Hooks() []Hook {
	return c.hooks.Dimension
}

// ItemClient is a client for the Item schema.
type ItemClient struct {
	config
}

// NewItemClient returns a client for the Item from the given config.
func NewItemClient(c config) *ItemClient {
	return &ItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `item.Hooks(f(g(h())))`.
func (c *ItemClient) Use(hooks ...Hook) {
	c.hooks.Item = append(c.hooks.Item, hooks...)
}

// Create returns a create builder for Item.
func (c *ItemClient) Create() *ItemCreate {
	mutation := newItemMutation(c.config, OpCreate)
	return &ItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Item entities.
func (c *ItemClient) CreateBulk(builders ...*ItemCreate) *ItemCreateBulk {
	return &ItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Item.
func (c *ItemClient) Update() *ItemUpdate {
	mutation := newItemMutation(c.config, OpUpdate)
	return &ItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ItemClient) UpdateOne(i *Item) *ItemUpdateOne {
	mutation := newItemMutation(c.config, OpUpdateOne, withItem(i))
	return &ItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ItemClient) UpdateOneID(id int) *ItemUpdateOne {
	mutation := newItemMutation(c.config, OpUpdateOne, withItemID(id))
	return &ItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Item.
func (c *ItemClient) Delete() *ItemDelete {
	mutation := newItemMutation(c.config, OpDelete)
	return &ItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ItemClient) DeleteOne(i *Item) *ItemDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ItemClient) DeleteOneID(id int) *ItemDeleteOne {
	builder := c.Delete().Where(item.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ItemDeleteOne{builder}
}

// Query returns a query builder for Item.
func (c *ItemClient) Query() *ItemQuery {
	return &ItemQuery{
		config: c.config,
	}
}

// Get returns a Item entity by its id.
func (c *ItemClient) Get(ctx context.Context, id int) (*Item, error) {
	return c.Query().Where(item.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ItemClient) GetX(ctx context.Context, id int) *Item {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDimensions queries the dimensions edge of a Item.
func (c *ItemClient) QueryDimensions(i *Item) *DimensionQuery {
	query := &DimensionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(dimension.Table, dimension.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, item.DimensionsTable, item.DimensionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskInstance queries the task_instance edge of a Item.
func (c *ItemClient) QueryTaskInstance(i *Item) *TaskInstanceQuery {
	query := &TaskInstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(taskinstance.Table, taskinstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, item.TaskInstanceTable, item.TaskInstanceColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetric queries the metric edge of a Item.
func (c *ItemClient) QueryMetric(i *Item) *MetricQuery {
	query := &MetricQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(item.Table, item.FieldID, id),
			sqlgraph.To(metric.Table, metric.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, item.MetricTable, item.MetricColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ItemClient) Hooks() []Hook {
	return c.hooks.Item
}

// MetricClient is a client for the Metric schema.
type MetricClient struct {
	config
}

// NewMetricClient returns a client for the Metric from the given config.
func NewMetricClient(c config) *MetricClient {
	return &MetricClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metric.Hooks(f(g(h())))`.
func (c *MetricClient) Use(hooks ...Hook) {
	c.hooks.Metric = append(c.hooks.Metric, hooks...)
}

// Create returns a create builder for Metric.
func (c *MetricClient) Create() *MetricCreate {
	mutation := newMetricMutation(c.config, OpCreate)
	return &MetricCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metric entities.
func (c *MetricClient) CreateBulk(builders ...*MetricCreate) *MetricCreateBulk {
	return &MetricCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metric.
func (c *MetricClient) Update() *MetricUpdate {
	mutation := newMetricMutation(c.config, OpUpdate)
	return &MetricUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetricClient) UpdateOne(m *Metric) *MetricUpdateOne {
	mutation := newMetricMutation(c.config, OpUpdateOne, withMetric(m))
	return &MetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetricClient) UpdateOneID(id int) *MetricUpdateOne {
	mutation := newMetricMutation(c.config, OpUpdateOne, withMetricID(id))
	return &MetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metric.
func (c *MetricClient) Delete() *MetricDelete {
	mutation := newMetricMutation(c.config, OpDelete)
	return &MetricDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MetricClient) DeleteOne(m *Metric) *MetricDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MetricClient) DeleteOneID(id int) *MetricDeleteOne {
	builder := c.Delete().Where(metric.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetricDeleteOne{builder}
}

// Query returns a query builder for Metric.
func (c *MetricClient) Query() *MetricQuery {
	return &MetricQuery{
		config: c.config,
	}
}

// Get returns a Metric entity by its id.
func (c *MetricClient) Get(ctx context.Context, id int) (*Metric, error) {
	return c.Query().Where(metric.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetricClient) GetX(ctx context.Context, id int) *Metric {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Metric.
func (c *MetricClient) QueryItems(m *Metric) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metric.Table, metric.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, metric.ItemsTable, metric.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a Metric.
func (c *MetricClient) QueryTask(m *Metric) *TaskQuery {
	query := &TaskQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metric.Table, metric.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metric.TaskTable, metric.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetricClient) Hooks() []Hook {
	return c.hooks.Metric
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Create returns a create builder for Task.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstances queries the instances edge of a Task.
func (c *TaskClient) QueryInstances(t *Task) *TaskInstanceQuery {
	query := &TaskInstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(taskinstance.Table, taskinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.InstancesTable, task.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetrics queries the metrics edge of a Task.
func (c *TaskClient) QueryMetrics(t *Task) *MetricQuery {
	query := &MetricQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(metric.Table, metric.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.MetricsTable, task.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a Task.
func (c *TaskClient) QueryCategory(t *Task) *TaskCategoryQuery {
	query := &TaskCategoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(taskcategory.Table, taskcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.CategoryTable, task.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Task.
func (c *TaskClient) QueryTags(t *Task) *TaskTagQuery {
	query := &TaskTagQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(tasktag.Table, tasktag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, task.TagsTable, task.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// TaskCategoryClient is a client for the TaskCategory schema.
type TaskCategoryClient struct {
	config
}

// NewTaskCategoryClient returns a client for the TaskCategory from the given config.
func NewTaskCategoryClient(c config) *TaskCategoryClient {
	return &TaskCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskcategory.Hooks(f(g(h())))`.
func (c *TaskCategoryClient) Use(hooks ...Hook) {
	c.hooks.TaskCategory = append(c.hooks.TaskCategory, hooks...)
}

// Create returns a create builder for TaskCategory.
func (c *TaskCategoryClient) Create() *TaskCategoryCreate {
	mutation := newTaskCategoryMutation(c.config, OpCreate)
	return &TaskCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskCategory entities.
func (c *TaskCategoryClient) CreateBulk(builders ...*TaskCategoryCreate) *TaskCategoryCreateBulk {
	return &TaskCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskCategory.
func (c *TaskCategoryClient) Update() *TaskCategoryUpdate {
	mutation := newTaskCategoryMutation(c.config, OpUpdate)
	return &TaskCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskCategoryClient) UpdateOne(tc *TaskCategory) *TaskCategoryUpdateOne {
	mutation := newTaskCategoryMutation(c.config, OpUpdateOne, withTaskCategory(tc))
	return &TaskCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskCategoryClient) UpdateOneID(id int) *TaskCategoryUpdateOne {
	mutation := newTaskCategoryMutation(c.config, OpUpdateOne, withTaskCategoryID(id))
	return &TaskCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskCategory.
func (c *TaskCategoryClient) Delete() *TaskCategoryDelete {
	mutation := newTaskCategoryMutation(c.config, OpDelete)
	return &TaskCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TaskCategoryClient) DeleteOne(tc *TaskCategory) *TaskCategoryDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TaskCategoryClient) DeleteOneID(id int) *TaskCategoryDeleteOne {
	builder := c.Delete().Where(taskcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskCategoryDeleteOne{builder}
}

// Query returns a query builder for TaskCategory.
func (c *TaskCategoryClient) Query() *TaskCategoryQuery {
	return &TaskCategoryQuery{
		config: c.config,
	}
}

// Get returns a TaskCategory entity by its id.
func (c *TaskCategoryClient) Get(ctx context.Context, id int) (*TaskCategory, error) {
	return c.Query().Where(taskcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskCategoryClient) GetX(ctx context.Context, id int) *TaskCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a TaskCategory.
func (c *TaskCategoryClient) QueryTasks(tc *TaskCategory) *TaskQuery {
	query := &TaskQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskcategory.Table, taskcategory.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, taskcategory.TasksTable, taskcategory.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskCategoryClient) Hooks() []Hook {
	return c.hooks.TaskCategory
}

// TaskInstanceClient is a client for the TaskInstance schema.
type TaskInstanceClient struct {
	config
}

// NewTaskInstanceClient returns a client for the TaskInstance from the given config.
func NewTaskInstanceClient(c config) *TaskInstanceClient {
	return &TaskInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskinstance.Hooks(f(g(h())))`.
func (c *TaskInstanceClient) Use(hooks ...Hook) {
	c.hooks.TaskInstance = append(c.hooks.TaskInstance, hooks...)
}

// Create returns a create builder for TaskInstance.
func (c *TaskInstanceClient) Create() *TaskInstanceCreate {
	mutation := newTaskInstanceMutation(c.config, OpCreate)
	return &TaskInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskInstance entities.
func (c *TaskInstanceClient) CreateBulk(builders ...*TaskInstanceCreate) *TaskInstanceCreateBulk {
	return &TaskInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskInstance.
func (c *TaskInstanceClient) Update() *TaskInstanceUpdate {
	mutation := newTaskInstanceMutation(c.config, OpUpdate)
	return &TaskInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskInstanceClient) UpdateOne(ti *TaskInstance) *TaskInstanceUpdateOne {
	mutation := newTaskInstanceMutation(c.config, OpUpdateOne, withTaskInstance(ti))
	return &TaskInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskInstanceClient) UpdateOneID(id int) *TaskInstanceUpdateOne {
	mutation := newTaskInstanceMutation(c.config, OpUpdateOne, withTaskInstanceID(id))
	return &TaskInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskInstance.
func (c *TaskInstanceClient) Delete() *TaskInstanceDelete {
	mutation := newTaskInstanceMutation(c.config, OpDelete)
	return &TaskInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TaskInstanceClient) DeleteOne(ti *TaskInstance) *TaskInstanceDeleteOne {
	return c.DeleteOneID(ti.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TaskInstanceClient) DeleteOneID(id int) *TaskInstanceDeleteOne {
	builder := c.Delete().Where(taskinstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskInstanceDeleteOne{builder}
}

// Query returns a query builder for TaskInstance.
func (c *TaskInstanceClient) Query() *TaskInstanceQuery {
	return &TaskInstanceQuery{
		config: c.config,
	}
}

// Get returns a TaskInstance entity by its id.
func (c *TaskInstanceClient) Get(ctx context.Context, id int) (*TaskInstance, error) {
	return c.Query().Where(taskinstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskInstanceClient) GetX(ctx context.Context, id int) *TaskInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a TaskInstance.
func (c *TaskInstanceClient) QueryItems(ti *TaskInstance) *ItemQuery {
	query := &ItemQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskinstance.Table, taskinstance.FieldID, id),
			sqlgraph.To(item.Table, item.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, taskinstance.ItemsTable, taskinstance.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a TaskInstance.
func (c *TaskInstanceClient) QueryTask(ti *TaskInstance) *TaskQuery {
	query := &TaskQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskinstance.Table, taskinstance.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, taskinstance.TaskTable, taskinstance.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskInstanceClient) Hooks() []Hook {
	return c.hooks.TaskInstance
}

// TaskTagClient is a client for the TaskTag schema.
type TaskTagClient struct {
	config
}

// NewTaskTagClient returns a client for the TaskTag from the given config.
func NewTaskTagClient(c config) *TaskTagClient {
	return &TaskTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tasktag.Hooks(f(g(h())))`.
func (c *TaskTagClient) Use(hooks ...Hook) {
	c.hooks.TaskTag = append(c.hooks.TaskTag, hooks...)
}

// Create returns a create builder for TaskTag.
func (c *TaskTagClient) Create() *TaskTagCreate {
	mutation := newTaskTagMutation(c.config, OpCreate)
	return &TaskTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskTag entities.
func (c *TaskTagClient) CreateBulk(builders ...*TaskTagCreate) *TaskTagCreateBulk {
	return &TaskTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskTag.
func (c *TaskTagClient) Update() *TaskTagUpdate {
	mutation := newTaskTagMutation(c.config, OpUpdate)
	return &TaskTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskTagClient) UpdateOne(tt *TaskTag) *TaskTagUpdateOne {
	mutation := newTaskTagMutation(c.config, OpUpdateOne, withTaskTag(tt))
	return &TaskTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskTagClient) UpdateOneID(id int) *TaskTagUpdateOne {
	mutation := newTaskTagMutation(c.config, OpUpdateOne, withTaskTagID(id))
	return &TaskTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskTag.
func (c *TaskTagClient) Delete() *TaskTagDelete {
	mutation := newTaskTagMutation(c.config, OpDelete)
	return &TaskTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TaskTagClient) DeleteOne(tt *TaskTag) *TaskTagDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TaskTagClient) DeleteOneID(id int) *TaskTagDeleteOne {
	builder := c.Delete().Where(tasktag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskTagDeleteOne{builder}
}

// Query returns a query builder for TaskTag.
func (c *TaskTagClient) Query() *TaskTagQuery {
	return &TaskTagQuery{
		config: c.config,
	}
}

// Get returns a TaskTag entity by its id.
func (c *TaskTagClient) Get(ctx context.Context, id int) (*TaskTag, error) {
	return c.Query().Where(tasktag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskTagClient) GetX(ctx context.Context, id int) *TaskTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a TaskTag.
func (c *TaskTagClient) QueryTasks(tt *TaskTag) *TaskQuery {
	query := &TaskQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tasktag.Table, tasktag.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tasktag.TasksTable, tasktag.TasksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskTagClient) Hooks() []Hook {
	return c.hooks.TaskTag
}
